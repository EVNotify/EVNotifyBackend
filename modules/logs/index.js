/**
 * @file modules/logs/index.js
 * @author GPlay97
 * @description Module for drives and charging logs
 */
const fs = require('fs');
const db = require('./../db');
const token = require('./../token');
const srv_config = require('./../../srv_config.json');
const srv_errors = require('./../../srv_errors.json');
const util = require('util');
const query = util.promisify(db.query);
const mail = require('../notification/mail');
const report = require('../report');

/**
 * Creates manual log for given log object
 * @param {String} akey the AKey
 * @param {Object} log the log object containing details of log entry
 */
const createLog = async (akey, log) => {
    try {
        return query('INSERT INTO logs (akey, start, end, charge, autogenerated, title) VALUES (?, ?, ?, ?, ?, ?)', [
            akey, log.start, log.end, log.charge || 0, 0, log.title
        ]);
    } catch (err) {
        console.error(err);
    }
    throw new Error(srv_errors.DB_QUERY.message);
};

/**
 * Retrieves logs for given AKey
 * @param {String} akey the AKey
 * @param {Boolean} charge selects charges or drives only
 * @return {Array} Array of logs
 */
const getLogs = async (akey, charge) => query('SELECT * FROM logs WHERE akey=? AND charge=? ORDER BY start DESC', [akey, charge]);

/**
 * Resolves log from given AKey for given log id
 * @param {String} akey the AKey
 * @param {Number} id the log id
 * @returns {Object} Log object
 */
const getLog = async (akey, id) => {
    let log = (await query('SELECT * FROM logs WHERE akey=? AND id=?', [akey, id]))[0];

    if (log != null) {
        let table = 'statistics';

        if (log.archived && !log.standalone) {
            table = `statistics_${new Date(log.start * 1000).getMonth() + 1}_${new Date(log.start * 1000).getFullYear()}`;
        } else if (log.archived && log.standalone) {
            table = `statistics_log_${id}`;
        }

        log.stats = await query(`SELECT * FROM ${table} WHERE akey=? AND timestamp >= ? AND timestamp <= ? ORDER BY timestamp DESC`, [akey, log.start, log.end]);
        // sort manually, based on location timestamp to prevent wrong order on location submission through server delay
        log.stats = log.stats.sort((a, b) => {
            return (b.location_timestamp || b.timestamp * 1000) - (a.location_timestamp || a.timestamp * 1000);
        });
        return log;
    }
    throw new Error(srv_errors.NOT_FOUND.message);
};

const getLatestLog = async (akey) => {
    return (await query('SELECT * FROM logs WHERE akey=? ORDER BY start DESC LIMIT 1', [akey]))[0];
};

/**
 * Updates log for given AKey and log id
 * @param {String} akey the AKey
 * @param {Object} log the new log object containing also the id of log
 */
const updateLog = async (akey, log) => {
    let dbLog = (await query('SELECT id FROM logs WHERE akey=? AND id=?', [akey, log.id]))[0];
    const start = (dbLog.autogenerated || dbLog.archived) ? dbLog.start : log.start;
    const end = (dbLog.autogenerated || dbLog.archived) ? dbLog.end : log.end;

    if (dbLog != null) {
        return await query('UPDATE logs SET start=?, end=?, charge=?, title=? WHERE id=?', [
            start, end, log.charge, log.title, log.id
        ]);
    }
    throw new Error(srv_errors.NOT_FOUND.message);
};

/**
 * Deletes the given log with its corresponding statistics
 * @param {String} akey the AKey
 * @param {Number} id the log id
 */
const deleteLog = async (akey, id) => {
    const log = (await query('SELECT start, end, autogenerated FROM logs WHERE akey=? AND id=?', [akey, id]))[0];

    if (log != null) {
        const queries = [query('DELETE FROM logs WHERE id=?', [id])];

        if (log.autogenerated) {
            let table = 'statistics';

            if (log.archived && !log.standalone) {
                table = `statistics_${new Date(log.start * 1000).getMonth() + 1}_${new Date(log.start * 1000).getFullYear()}`;
            } else if (log.archived && log.standalone) {
                table = `statistics_log_${id}`;
            }

            queries.push(query(`DELETE FROM ${table} WHERE timestamp >= ? AND timestamp <= ? AND akey=?'`, [log.start, log.end, akey]));
        }
        return Promise.all(queries);
    }
    throw new Error(srv_errors.NOT_FOUND.message);
};

/**
 * Exports given log data and sends the file to given email
 * @param {String} akey the AKey
 * @param {Number} id the log id
 * @param {String} email the email where export will be sent to
 */
const exportLog = async (akey, id, email) => {
    const log = (await query('SELECT start, end, archived, autogenerated FROM logs where akey=? and id=?', [akey, id]))[0];

    if (log != null) {
        if (!log.autogenerated) throw new Error(srv_errors.LOG_EXPORT_UNAVAILABLE.message);
        
        let table = 'statistics';

        if (log.archived && !log.standalone) {
            table = `statistics_${new Date(log.start * 1000).getMonth() + 1}_${new Date(log.start * 1000).getFullYear()}`;
        } else if (log.archived && log.standalone) {
            table = `statistics_log_${id}`;
        }

        const statistics = (await query(`SELECT * FROM ${table} WHERE akey=? AND timestamp >= ? AND timestamp <= ?`, [akey, log.start, log.end]));

        return report.logExportReport(statistics).then((file) => {
            // TODO localize
            mail.simpleSend(email, 'Log-Export', 'Log-Export', [{
                filename: 'Export.xlsx',
                path: file
            }], (err) => {
                fs.unlink(file, (err) => {
                    if (err) console.warn('Could not delete tmp file', file);
                });
            });
        });
    }
    throw new Error(srv_errors.NOT_FOUND.message);
};

module.exports = {
    /**
     * createLog request handler
     * @param {Object} req the server request
     * @param {Object} res the server response
     */
    createLog: (req, res) => {
        // check required params TODO: validate title, start and end (and also validate if start smaller than end and end not newer than now)
        if (!req.body.akey || !req.body.token || typeof req.body.log !== 'object' || req.body.log == null || !req.body.log.title || !req.body.log.start || !req.body.log.end) {
            return res.status(400).json({
                error: srv_errors.INVALID_PARAMETERS
            });
        }
        // validate token
        token.validateToken(req.body.akey, req.body.token, (err, valid) => {
            if (!err) {
                if (valid) {
                    // create the log
                    createLog(req.body.akey, req.body.log).then(() => res.json({
                        created: true
                    })).catch(err => {
                        res.status(422).json({
                            error: srv_errors.UNPROCESSABLE_ENTITY,
                            debug: ((srv_config.DEBUG) ? err : null)
                        });
                    });
                } else {
                    // invalid token
                    res.status(401).json({
                        error: srv_errors.INVALID_TOKEN
                    });
                }
            } else {
                res.status(422).json({
                    error: srv_errors.UNPROCESSABLE_ENTITY,
                    debug: ((srv_config.DEBUG) ? err : null)
                });
            }
        });
    },
    /**
     * getLogs request handler
     * @param {Object} req the server request
     * @param {Object} res the server response
     */
    getLogs: (req, res) => {
        // check required params
        if (!req.query.akey || !req.query.token) {
            return res.status(400).json({
                error: srv_errors.INVALID_PARAMETERS
            });
        }
        // validate token
        token.validateToken(req.query.akey, req.query.token, (err, valid) => {
            if (!err) {
                if (valid) {
                    // retrieve the logs
                    getLogs(req.query.akey, (parseInt(req.query.charge) === 1)).then(logs => res.json(logs)).catch(err => {
                        res.status(422).json({
                            error: srv_errors.UNPROCESSABLE_ENTITY,
                            debug: ((srv_config.DEBUG) ? err : null)
                        });
                    });
                } else {
                    // invalid token
                    res.status(401).json({
                        error: srv_errors.INVALID_TOKEN
                    });
                }
            } else {
                res.status(422).json({
                    error: srv_errors.UNPROCESSABLE_ENTITY,
                    debug: ((srv_config.DEBUG) ? err : null)
                });
            }
        });
    },
    /**
     * getLog request handler
     * @param {Object} req the server request
     * @param {Object} res the server response
     */
    getLog: (req, res) => {
        // check required params TODO: validate id number
        if (!req.query.akey || !req.query.token || !req.query.id) {
            return res.status(400).json({
                error: srv_errors.INVALID_PARAMETERS
            });
        }
        // validate token
        token.validateToken(req.query.akey, req.query.token, (err, valid) => {
            if (!err) {
                if (valid) {
                    // retrieve log details
                    getLog(req.query.akey, req.query.id).then(log => res.json(log)).catch(err => {
                        res.status(422).json({
                            error: srv_errors.UNPROCESSABLE_ENTITY,
                            debug: ((srv_config.DEBUG) ? ((err && err.message) ? err.message : err) : null)
                        });
                    });
                } else {
                    // invalid token
                    res.status(401).json({
                        error: srv_errors.INVALID_TOKEN
                    });
                }

            } else {
                res.status(422).json({
                    error: srv_errors.UNPROCESSABLE_ENTITY,
                    debug: ((srv_config.DEBUG) ? err : null)
                });
            }
        });
    },
    /**
     * getLatestLog request handler
     * @param {Object} req the server request
     * @param {Object} res the server response
     */
    getLatestLog: (req, res) => {
        // check required params
        if (!req.query.akey || !req.query.token) {
            return res.status(400).json({
                error: srv_errors.INVALID_PARAMETERS
            });
        }
        // validate token
        token.validateToken(req.query.akey, req.query.token, (err, valid) => {
            if (!err) {
                if (valid) {
                    // retrieve latest log
                    getLatestLog(req.query.akey).then(log => res.json(log)).catch(err => {
                        res.status(422).json({
                            error: srv_errors.UNPROCESSABLE_ENTITY,
                            debug: ((srv_config.DEBUG) ? ((err && err.message) ? err.message : err) : null)
                        });
                    });
                } else {
                    // invalid token
                    res.status(401).json({
                        error: srv_errors.INVALID_TOKEN
                    });
                }

            } else {
                res.status(422).json({
                    error: srv_errors.UNPROCESSABLE_ENTITY,
                    debug: ((srv_config.DEBUG) ? err : null)
                });
            }
        });
    },
    /**
     * updateLog request handler
     * @param {Object} req the server request
     * @param {Object} res the server response
     */
    updateLog: (req, res) => {
        // check required params TODO: validate id number, title, start and end (and also validate if start smaller than end and end not newer than now)
        if (!req.body.akey || !req.body.token || typeof req.body.log !== 'object' || req.body.log == null || !req.body.log.id) {
            return res.status(400).json({
                error: srv_errors.INVALID_PARAMETERS
            });
        }
        // validate token
        token.validateToken(req.body.akey, req.body.token, (err, valid) => {
            if (!err) {
                if (valid) {
                    // updates the given log
                    updateLog(req.body.akey, req.body.log).then(() => {
                        res.json({
                            updated: true
                        });
                    }).catch(err => {
                        res.status(422).json({
                            error: srv_errors.UNPROCESSABLE_ENTITY,
                            debug: ((srv_config.DEBUG) ? err : null)
                        });
                    });
                } else {
                    // invalid token
                    res.status(401).json({
                        error: srv_errors.INVALID_TOKEN
                    });
                }
            } else {
                res.status(422).json({
                    error: srv_errors.UNPROCESSABLE_ENTITY,
                    debug: ((srv_config.DEBUG) ? err : null)
                });
            }
        });
    },
    /**
     * deleteLog request handler
     * @param {Object} req the server request
     * @param {Object} res the server response
     */
    deleteLog: (req, res) => {
        // check required params TODO: validate id number
        if (!req.body.akey || !req.body.token || !req.body.id) {
            return res.status(400).json({
                error: srv_errors.INVALID_PARAMETERS
            });
        }
        // validate token
        token.validateToken(req.body.akey, req.body.token, (err, valid) => {
            if (!err) {
                if (valid) {
                    // delete the given log
                    deleteLog(req.body.akey, req.body.id).then(() => {
                        res.json({
                            deleted: true
                        });
                    }).catch(err => {
                        res.status(422).json({
                            error: srv_errors.UNPROCESSABLE_ENTITY,
                            debug: ((srv_config.DEBUG) ? err : null)
                        });
                    });
                } else {
                    // invalid token
                    res.status(401).json({
                        error: srv_errors.INVALID_TOKEN
                    });
                }
            } else {
                res.status(422).json({
                    error: srv_errors.UNPROCESSABLE_ENTITY,
                    debug: ((srv_config.DEBUG) ? err : null)
                });
            }
        });
    },
    exportLog: (req, res) => {
        // check required params TODO: validate id number
        if (!req.query.akey || !req.query.token || !req.query.id || !mail.validateMail(req.query.email)) {
            return res.status(400).json({
                error: srv_errors.INVALID_PARAMETERS
            });
        }
        // validate token
        token.validateToken(req.query.akey, req.query.token, (err, valid) => {
            if (!err) {
                if (valid) {
                    exportLog(req.query.akey, req.query.id, req.query.email).then(() => {
                        res.json({
                            exported: true
                        });
                    }).catch((err) => {
                        res.status(422).json({
                            error: srv_errors.UNPROCESSABLE_ENTITY,
                            debug: ((srv_config.DEBUG) ? err : null)
                        });
                    });
                } else {
                    // invalid token
                    res.status(401).json({
                        error: srv_errors.INVALID_TOKEN
                    });
                }
            } else {
                res.status(422).json({
                    error: srv_errors.UNPROCESSABLE_ENTITY,
                    debug: ((srv_config.DEBUG) ? err : null)
                });
            }
        });
    }
};
